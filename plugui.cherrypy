#!/usr/bin/python2
"""
Idea and code snippets borrowed from http://www.xhtml.net/scripts/Django-CherryPy-server-DjangoCerise
Adapted to run as a management command
"""


import logging, sys, os, signal, time, errno
from socket import gethostname
from django.core.management.base import BaseCommand
from django.utils.daemonize import become_daemon
import ConfigParser, os

config = ConfigParser.RawConfigParser()

if not os.path.exists('/etc/plugui.conf'):
	config.add_section('Global')
	config.set('Global', 'host', '0.0.0.0')
	config.set('Global', 'port', '80')
	config.set('Global', 'server_name', 'localhost')
	config.set('Global', 'threads', '10')
	config.set('Global', 'daemonize', True)
	config.set('Global', 'workdir', '/opt/PlugUI')
	config.set('Global', 'pypath', '/opt')
	config.set('Global', 'pidfile', '/var/run/PlugUI/server.pid')
	config.set('Global', 'server_user', 'root')		
	config.set('Global', 'server_group', 'root')
	
	with open('/etc/plugui.conf', 'wb') as configfile:
		config.write(configfile)

else:
	config.readfp(open('/etc/plugui.conf'))




CPSERVER_OPTIONS = {
'host': config.get("Global", "host"),
'port': config.get("Global", "port"),
'server_name': config.get("Global", "server_name"),
'threads': config.get("Global", "threads"), 
'daemonize': config.get("Global", "daemonize"),
'workdir': config.get("Global", "workdir"),
'pypath': config.get("Global", "pypath"),
'pidfile': config.get("Global", "pidfile"),
'server_user': config.get("Global", "server_user"),
'server_group': config.get("Global", "server_group"),
}


class Command(BaseCommand):
    help = "CherryPy Server for project. Requires CherryPy."
    args = "[various KEY=val options, use `runcpserver help` for help]"

    def handle(self, *args, **options):
        from django.conf import settings
        from django.utils import translation
        # Activate the current language, because it won't get activated later.
        try:
            translation.activate(settings.LANGUAGE_CODE)
        except AttributeError:
            pass
        runcpserver(args)
        
    def usage(self, subcommand):
        return ""

def change_uid_gid(uid, gid=None):
    """Try to change UID and GID to the provided values.
    UID and GID are given as names like 'nobody' not integer.

    Src: http://mail.mems-exchange.org/durusmail/quixote-users/4940/1/
    """
    if not os.geteuid() == 0:
        # Do not try to change the gid/uid if not root.
        return
    (uid, gid) = get_uid_gid(uid, gid)
    os.setgid(gid)
    os.setuid(uid)

def get_uid_gid(uid, gid=None):
    """Try to change UID and GID to the provided values.
    UID and GID are given as names like 'nobody' not integer.

    Src: http://mail.mems-exchange.org/durusmail/quixote-users/4940/1/
    """
    import pwd, grp
    uid, default_grp = pwd.getpwnam(uid)[2:4]
    if gid is None:
        gid = default_grp
    else:
        try:
            gid = grp.getgrnam(gid)[2]            
        except KeyError:
            gid = default_grp
    return (uid, gid)
    
    
def poll_process(pid):
    """
    Poll for process with given pid up to 10 times waiting .25 seconds in between each poll. 
    Returns False if the process no longer exists otherwise, True.
    """
    for n in range(10):
        time.sleep(0.25)
        try:
            # poll the process state
            os.kill(pid, 0)
        except OSError, e:
            if e[0] == errno.ESRCH:
                # process has died
                return False
            else:
                raise #TODO
    return True

def stop_server(pidfile):
    """
    Stop process whose pid was written to supplied pidfile. 
    First try SIGTERM and if it fails, SIGKILL. If process is still running, an exception is raised.
    """
    if os.path.exists(pidfile):
        pid = int(open(pidfile).read())
        try:
            os.kill(pid, signal.SIGTERM)
        except OSError: #process does not exist
            os.remove(pidfile)
            return
        if poll_process(pid):
            #process didn't exit cleanly, make one last effort to kill it
            os.kill(pid, signal.SIGKILL)
            if still_alive(pid):
                raise OSError, "Process %s did not stop."
        os.remove(pidfile)

def start_server(options):
    """
    Start CherryPy server
    """
    
    if options['daemonize'] and options['server_user'] and options['server_group']:
        #ensure the that the daemon runs as specified user
        change_uid_gid(options['server_user'], options['server_group'])
    
    from cherrypy.wsgiserver import CherryPyWSGIServer as Server
    from django.core.handlers.wsgi import WSGIHandler
    server = Server(
        (options['host'], int(options['port'])),
        WSGIHandler(), 
        int(options['threads']), 
        options['server_name']
    )
    try:
        server.start()
    except KeyboardInterrupt:
        server.stop()


def runcpserver(argset=[], **kwargs):
    # Get the options
    options = CPSERVER_OPTIONS.copy()
    options.update(kwargs)

    newpath = options['pypath']
    if newpath not in sys.path:
        sys.path.append(newpath)
    os.environ['DJANGO_SETTINGS_MODULE'] = 'PlugUI.settings'


    for x in argset:
        if "=" in x:
            k, v = x.split('=', 1)
        else:
            k, v = x, True
        options[k.lower()] = v
        
    if "stop" in options:
        stop_server(options['pidfile'])
        return True
    
    if options['daemonize']:
        stop_server(options['pidfile'])     
        if options['workdir']:
            become_daemon(our_home_dir=options['workdir'])
        else:
            become_daemon()

        fp = open(options['pidfile'], 'w')
        fp.write("%d\n" % os.getpid())
        fp.close()
    
    # Start the webserver
    print 'starting server with options %s' % options
    start_server(options)


if __name__ == '__main__':
    runcpserver(sys.argv[1:])
